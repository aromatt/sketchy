var searchIndex = {};
searchIndex['sketchy'] = {"items":[[0,"","sketchy","Sketchy is a Rust library of probabilistic data structures, useful for measuring large or\nunbounded streams of data by trading some accuracy for a whole lot of efficiency.",null,null],[3,"BloomFilter","","A Bloom filter is a space-efficient probabilistic data structure that is used to test whether an\nelement is a member of a set. False positive matches are possible, but false negatives are not.",null,null],[3,"CountMinSketch","","A Count-Min Sketch is a probabilistic data structure which provides estimates of the frequency\nof elements in a data stream. It is parameterized with the type of elements.",null,null],[3,"HyperLogLog","","A HyperLogLog allows for space-efficient estimates of the cardinality of large multisets.",null,null],[3,"ReservoirSample","","A reservoir sample maintains a sample of K elements, selected uniformly and at random from a\nstream. This implementation uses [Vitter's Algorithm\nR](http://www.cs.umd.edu/~samir/498/vitter.pdf) with thread-local PRNGs.",null,null],[3,"TopK","","A Top-K heap is a probabilistic data structure which uses a Count-Min Sketch to calculate the\ntop K elements in a data stream with the highest frequency.",null,null],[11,"new","","Creates a new `BloomFilter` instance, tuned for a population of `n` elements with the given\nupper bound of the probability of false positives.",0,{"inputs":[{"name":"bloomfilter"},{"name":"usize"},{"name":"f64"}],"output":{"name":"bloomfilter"}}],[11,"insert","","Adds a value to the set.",0,{"inputs":[{"name":"bloomfilter"},{"name":"e"}],"output":null}],[11,"contains","","Returns `true` if the set probably contains the given element.",0,{"inputs":[{"name":"bloomfilter"},{"name":"e"}],"output":{"name":"bool"}}],[11,"merge","","Merges the contents of the given `BloomFilter` into `self`. Both filters must have the same\nparameters. Returns true if self changed.",0,{"inputs":[{"name":"bloomfilter"},{"name":"bloomfilter"}],"output":{"name":"bool"}}],[11,"with_confidence","","Returns a `CountMinSketch` which provides frequency estimates where the error is within a\nfactor of epsilon with the given confidence.",1,{"inputs":[{"name":"countminsketch"},{"name":"f64"},{"name":"f64"}],"output":{"name":"countminsketch"}}],[11,"new","","Returns a `CountMinSketch` with the given depth and width.",1,{"inputs":[{"name":"countminsketch"},{"name":"usize"},{"name":"usize"}],"output":{"name":"countminsketch"}}],[11,"insert","","Adds a value to the sketch.",1,{"inputs":[{"name":"countminsketch"},{"name":"e"}],"output":null}],[11,"insert_n","","Adds multiple instances of a value to the sketch.",1,{"inputs":[{"name":"countminsketch"},{"name":"e"},{"name":"u64"}],"output":null}],[11,"estimate","","Estimates the frequency of the given element.",1,{"inputs":[{"name":"countminsketch"},{"name":"e"}],"output":{"name":"u64"}}],[11,"estimate_mean","","Estimates the frequency of the given element using the [Count-Mean-Min\nalgorithm](http://webdocs.cs.ualberta.ca/~fandeng/paper/cmm.pdf), which performs better on\ndata sets which aren't highly skewed.",1,{"inputs":[{"name":"countminsketch"},{"name":"e"},{"name":"u64"}],"output":{"name":"u64"}}],[11,"merge","","Merges another `CountMinSketch` into `self`.",1,{"inputs":[{"name":"countminsketch"},{"name":"countminsketch"}],"output":null}],[11,"new","","Returns a new `HyperLogLog` with the given margin of error.",2,{"inputs":[{"name":"hyperloglog"},{"name":"f64"}],"output":{"name":"hyperloglog"}}],[11,"insert","","Inserts an element of the multiset.",2,{"inputs":[{"name":"hyperloglog"},{"name":"e"}],"output":null}],[11,"insert_hashed","","Inserts the hash of an element of the multiset.",2,{"inputs":[{"name":"hyperloglog"},{"name":"u64"}],"output":null}],[11,"cardinality","","Returns an estimate of the cardinality of the multiset that was inserted.",2,{"inputs":[{"name":"hyperloglog"}],"output":{"name":"f64"}}],[11,"new","","Returns a new `ReservoirSample` of the given size.",3,{"inputs":[{"name":"reservoirsample"},{"name":"usize"}],"output":{"name":"reservoirsample"}}],[11,"insert","","Inserts the given element into the sample.",3,{"inputs":[{"name":"reservoirsample"},{"name":"e"}],"output":null}],[11,"elements","","Returns the recorded elements in the sample.",3,{"inputs":[{"name":"reservoirsample"}],"output":{"name":"vec"}}],[11,"new","","Returns a TopK which will track `k` elements with at least `min` frequency (`(0,1)`) using\nthe given CountMinSketch.",4,{"inputs":[{"name":"topk"},{"name":"usize"},{"name":"f64"},{"name":"countminsketch"}],"output":{"name":"topk"}}],[11,"insert","","Adds a value to the heap.",4,{"inputs":[{"name":"topk"},{"name":"e"}],"output":null}],[11,"elements","","Returns a vector of the top K elements, in reverse order of frequency.",4,{"inputs":[{"name":"topk"}],"output":{"name":"vec"}}],[11,"shrink_to_fit","","Shrinks the heap as much as possible while still retaining the top K elements. Should be\ncalled periodically to filter out false positives as the data stream changes.",4,{"inputs":[{"name":"topk"}],"output":null}]],"paths":[[3,"BloomFilter"],[3,"CountMinSketch"],[3,"HyperLogLog"],[3,"ReservoirSample"],[3,"TopK"]]};
initSearch(searchIndex);
