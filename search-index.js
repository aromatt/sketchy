var searchIndex = {};
searchIndex['sketchy'] = {"items":[[0,"","sketchy","Sketchy is a Rust library of probabilistic data structures, useful for\nmeasuring large or unbounded streams of data by trading some accuracy for a\nwhole lot of efficiency."],[3,"BloomFilter","","A Bloom filter is a space-efficient probabilistic data structure that is\nused to test whether an element is a member of a set. False positive matches\nare possible, but false negatives are not."],[3,"CountMinSketch","","A Count-Min Sketch is a probabilistic data structure which provides\nestimates of the frequency of elements in a data stream. It is parameterized\nwith the type of elements."],[3,"HyperLogLog","","A HyperLogLog allows for space-efficient estimates of the cardinality of\nlarge multisets."],[3,"ReservoirSample","","A reservoir sample maintains a sample of K elements, selected uniformly and\nat random from a stream. This implementation uses [Vitter's Algorithm\nR](http://www.cs.umd.edu/~samir/498/vitter.pdf) with thread-local PRNGs."],[3,"TopK","","A Top-K heap is a probabilistic data structure which uses a Count-Min Sketch\nto calculate the top K elements in a data stream with the highest frequency."],[11,"new","","Creates a new `BloomFilter` instance, tuned for a population of `n`\nelements with the given upper bound of the probability of false\npositives.",0],[11,"insert","","Adds a value to the set.",0],[11,"contains","","Returns `true` if the set probably contains the given element.",0],[11,"merge","","Merges the contents of the given `BloomFilter` into `self`. Both\nfilters must have the same parameters. Returns true if self changed.",0],[11,"with_confidence","","Returns a `CountMinSketch` which provides frequency estimates where the\nerror is within a factor of epsilon with the given confidence.",1],[11,"new","","Returns a `CountMinSketch` with the given depth and width.",1],[11,"insert","","Adds a value to the sketch.",1],[11,"insert_n","","Adds multiple instances of a value to the sketch.",1],[11,"estimate","","Estimates the frequency of the given element.",1],[11,"estimate_mean","","Estimates the frequency of the given element using the\n[Count-Mean-Min algorithm](http://webdocs.cs.ualberta.ca/~fandeng/paper/cmm.pdf),\nwhich performs better on data sets which aren't highly skewed.",1],[11,"merge","","Merges another `CountMinSketch` into `self`.",1],[11,"new","","Returns a new `HyperLogLog` with the given margin of error.",2],[11,"insert","","Inserts an element of the multiset.",2],[11,"cardinality","","Returns an estimate of the cardinality of the multiset that was\ninserted.",2],[11,"new","","Returns a new `ReservoirSample` of the given size.",3],[11,"insert","","Inserts the given element into the sample.",3],[11,"elements","","Returns the recorded elements in the sample.",3],[11,"new","","Returns a TopK which will track `k` elements with at least `min`\nfrequency (`(0,1)`) using the given CountMinSketch.",4],[11,"insert","","Adds a value to the heap.",4],[11,"elements","","Returns a vector of the top K elements, in reverse order of frequency.",4],[11,"shrink_to_fit","","Shrinks the heap as much as possible while still retaining the top K\nelements. Should be called periodically to filter out false positives as\nthe data stream changes.",4]],"paths":[[3,"BloomFilter"],[3,"CountMinSketch"],[3,"HyperLogLog"],[3,"ReservoirSample"],[3,"TopK"]]};
initSearch(searchIndex);
